				基础 LPC
			作者: Descartes of Borg
			第一版: 23 april 1993
			第二版: 17 june 1993

第三章: LPC  的资料型态 (data type)

3.1 你现在该知道的事

LPC 物件由零个或多个变数组合而成, 而这些变数由一个或多个函式组合而成. 
在程式码中, 这些函式的先后顺序是无关紧要的. 当你写的 LPC  第一次被参考
时, driver  把它复制一份到记忆体中. 之后, 还可藉此复制出更多相同的拷贝. 
任何一份物件被载入记忆体时, 所有的变数一开始都指向“虚无值”. 精简模式
mud 的 reset()  函式与原始模式的 create() 函式都都用于指定物件的初始变
数值. 物件载入记忆体之后, 会立刻呼叫创造的函式. 不过, 如果你读这份课本
之前没有写过程式, 你大概不知道什么是函式 (function) , 或函式是怎么被呼
叫的. 就算你以前写过程式, 你大概也想知道新创造的物件中, 函式之间互相呼
叫对方的过程是什么. 回答以上这些问题以前, 你得多了解函式在处理什么. 所
以你应该先彻底了解 LPC  资料型态背后的观念. 说实在的, 在这份手册里头最
无聊的主题, 也是最重要的主题, 90% 以上就是用错 LPC  资料型态 (放错 {}
和 () 不算在内).  所以说, 你得要耐心看完非常重要的这一章, 因为我觉得你
如果搞懂这一章, 可以让你以后写程式大大轻松不少.

3.2 与电脑沟通

你应该已经知道电脑不懂人类所使用的单字与数字. 电脑所说的“语言”由 0 
与 1  的“字母”所组合而成. 当然, 你知道电脑不懂人类的自然语言. 但是实
际上, 它们也不懂我们写给它们的电脑语言. 像是 BASIC、C、C++、Pascal 等等
, 这些电脑语言全都是过渡语言. 这些电脑语言让你能把想法组织起来, 让思考
更易转换成电脑的 0  与 1  语言.

转换有两个方法: 编译 (compilation)  和直译 (interpretation) . 这两个方
法的差别在于程式语言转换成真正电脑语言的时候. 对编译的程式语言来说, 程
式设计者撰写程式码之后, 使用编译程式 (compiler) 把程式码转换成电脑真正
的语言. 程式在执行之前就已经转换完毕. 而直译的程式语言, 在程式执行的时
候才开始转换. 因此直译的程式语言所写的程式执行起来要比编译的慢上许多.

总而言之, 不管你用什么程式语言撰写程式, 最后都要转变成 0  与 1  才能让
电脑搞懂. 但是你储存在记忆体中的变数并不是单纯的 0  与 1. 所以你用的程
式语言要有个方法告诉电脑, 这些 0  和 1  到底要当作十进位数字、字元
 (characters) 、字串 (string) 、还是当作其他的东西看待. 你可以靠着指定
资料型态来办到.

举例来说, 假设你有个变数叫做 x ,  而你给它一个十进位的值 ── 65. 在
LPC 里面, 你会写出下面的叙述:

-----
x = 65;
-----

你等一下再做像这样的事:

_____
write(x+"\n");        /* \n 符号代表在此换行 (carriage return) */
y = x + 5;
-----

第一行让你送出 65 和换行到某个人的荧幕上. 第二行让你把 y  设定为 70.  
问题是你告诉电脑 x = 65; 时,  它不知道 65 到底是啥意思. 你认为是 65,  
对电脑来说也许认为是:
00000000000000000000000001000001
而且, 对电脑来说, A 这个字母就是:
00000000000000000000000001000001
所以, 不管你什么时候告诉电脑 write(x+"\n");,  电脑总要有个方法知道你想
看到 65 而不是 A.

电脑能透过资料型态了解 65 与 A  的不同. 资料型态只是说记忆体位置中储存
的指定变数到底是属于什么型态的资料. 所以说, 每一个 LPC  变数都有变数型
态指导如何转换资料. 在上面的范例里, 你应该会在程式码“之前”加上以下这
行:

-----
int x;
-----

这一行告诉 driver 无论 x  指向何处, 都当作“int” 资料型态来使用. int 
是整数 (interger, 或称 whole number)  的缩写. 现在我们已经初步介绍为什
么要有资料型态. 这样一来, driver  才能搞清楚电脑储存在记忆体中的 0  与
1 到底是代表什么意义. 

3.3 LPC 的资料型态

所有的 LPMud driver 都有以下的资料型态:

void (无), status  (状况), int (整数), string  (字串), object  (物件), 
int *  (整数指标), string *  (字串指标), object *  (物件指标), 
mixed * (混合指标)

很多种 driver  (不是全部) 有下列资料型态值得讨论:

float  (浮点数), mapping  (映射), float *  (浮点数指标), 
mapping * (映射指标)

少数 driver 有下列罕用的资料型态, 并不值得讨论:

function (函式), enum, struct  (结构), char  (字元)

 (译注: 目前台湾绝大多数的 LPMud  所使用的 driver 是 MudOS, 其资料型态
有些许不同之处. 请详见参考译者所翻译之 MudOS  参考文件)

3.4 简单的资料型态

这份简介性质的课本会介绍 void, status, int, float, string, object, 
mixed 这几种资料型态. 你可以在中阶课本 (intermediate book,  译注: 本作
者另外有写一份中阶 LPC  手册, 译者亦有翻译) 找到像是 mapping (映射) 或
array (阵列)  这种更复杂的资料型态. 本章先介绍两种最简单的资料型态 (以
LPC 程式设计者的观点来看)  ── 整数 (int)  和字串 (string).

int 表示任何整数. 所以 1, 42, -17, 0, -10000023 都是整数 (int)  型态. 
string  是一个以上的字元或数字. 所以 "a", "we are borg", "42", 
"This is a string"  都是字串. 请注意, 字串前后都要加上双引号 "" , 
driver  才能分辨 int 42 和 string "42". 也才能区别变数名称 (像是 x )  
与字串 (像是 "x" ).

当你在程式码中使用变数, 你一开始要让 driver 知道这个变数所指的是哪种变
数型态. 这种处理方式叫做“宣告” (declaration). 你得在函式一开始的地方
宣告, 或是在物件程式码的开头之处 (在函式之外, 任何函式用到该变数之前).
要宣告变数型态的话, 只要像底下一样, 把变数型态摆在变数的名字前便即可.

-----
void add_two_and_two() {
    int x;
    int y;

    x = 2;
    y = x + x;
}
-----

像这样, 这是一个完整的函式. 函式的名称是 add_two_and_two(). 函式一开始
宣告一个整数变数 x, 之后宣告一个整数变数 y. 所以, 在这里 driver 有两个
变数指向 NULL  (虚无) 值, 而这两个变数期待的变数值是整数型态.

关于虚无 (void) 和状态 (status) 资料型态:

无 (void) 是一种很普遍的资料型态, 它不指向任何东西. 它并不是用在变数上面的
型态, 而是用于函式. 你稍后会了解这里所说的事. 而现在, 你只需要知道 void
不指向任何值.

状况 (status) 资料型态是布林 (boolean)  资料型态. 就是说, 它的值是 0  
或 1. 这种值常常称为真 (true) 或伪 (false).

3.5 本章总结

对变数来说, driver  需要知道电脑储存在记忆体中的 0  与 1  要如何转换成
你想使用的形式. 最简单的 LPC  资料型态是 void, status, int, string. 变
数不使用 void 的资料型态, 但是这种资料型态用于函式. 另外, 资料型态用于
转换格式, 决定 driver 应该使用哪种规则处理运算, 像是 +, - ......以此类
推. 举例说, 运算式 (expression) 5+5, driver 知道 5  加上 5  的值是 10.
对字串来说, 对字串使用整数加法没有意义. 所以, "a"+"b" 把 "b"  加在 "a"
的后面, 最后得出 "ab". 当你试着把 "5"+5 就会产生错误. 因为把整数加上字
串是无意义的, 所以 driver 会把第二个 5  转换成 "5"  再加起来. 最后的结
果是 "55".  如果你想看的结果是 10 , 你最后只得到错误的程式码. 请记住,
大多数的情况下, driver  不会像前面这样产生 "55" 这种有用的结果. 它会产
生 "55" 是因为它早有一条规则处理整数加上字串的情况, 也就是把整数当成字
串看待. 在大多数的状况中, 如果你在运算式或函式中使用资料型态并没有事先
定义 (像是你试着把 "this is"  除以 "nonsense", "this is" / "nonsense")
, driver  会呕吐并回报错误给你.

翻译:
	Spock of Final Frontier		98.Jan.22.
