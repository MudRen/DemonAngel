LPC 的 inherit 叙述:

语法: inherit 路径名称;

路径名称前后必须加上双引号 " ,  例如 "/std/object".

inherit 叙述提供 LPC  物件继承的能力 (从物件导向程式设计而来的观念).  继
承性 (inheritance)  让物件能继承其他物件的函式和变数. 因为 MudOS  驱动程
式将全域资料 (global data)  储存于内部, 并且将不同物件的程式码分开编译
(compile) , 所以许多不同的物件可以用继承能力分享同一段编译程式码. 每一个
物件会将任何全域变数再自己拷贝一份. 假设分别有两个物件 A  与 B  继承物件
C , 重新编译 A  或 B  不会使 C  也重新编译一次. 但是, 这样会让 A  或 B  
失去由 C  提供的全域变数值z记住, A 和 B  都有一份 C  提供之全域变数的拷
贝. 所以更新 (update) A 不会影响 B  的全域变数 ( C  提供的) , 反之亦然{. 

假设物件 A  继承物件 B. 物件 A  可以定义与 B  里面有相同名称的变数和函式.
如果 A  定义了一个与 B  中同名的函式, 则 A  定义的函式就外部 (override)
B 的函式定义. 如果 A  想使用 B  的定义, 可以这样做: 假设 A  定义了一个名
为 query_long 的函式, 而 A  又想呼叫 /std/object.c  物件中的 query_long
函式, 则 A  可以使用 object::query_long() 来呼叫. 如果 A  定义了与 B  中
同名的全域变数, 则 A  只能藉由呼叫 B  的函式以取得或操作 B  的同名全域变
数. 如果 B  定义的一个全域变数, 在 A  中并没有宣告 (declare)  过, 则 A  
可以使用这个全域变数, 就像是 A  自己的全域变数一样 (假设 B  没有限制其他
物件是否能存取此全域变数) 注意: 如果重新编译物件 B, A 会一直使用旧的 B
物件, 直到物件 A  也重新编译一次. 

您可以多重继承. 多重继承就是一个物件可以继承一个以上的物件. 假设 special.c
继承 weapon.c 和 armor.c, 而 weapon.c 和 armor.c  都提供了自己的
query_long()  函式. 让我们假设 special.c  有时候想当成一样武器, 而有时候
想当作一个护甲. 当 special.c  看来像是护甲时, 可以用 armor::query_long()
, 而看来像武器时, 就用 armor::query_long().

请参考 types/modifiers  此份文件, 说明被继承的物件可以对继承它的物件隐藏
资料和函式定义.

翻译:	Spock @ FF	97.Aug.10.
