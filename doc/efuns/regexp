名称：
	regexp - 正规表示式处理程式 (regular expression handler)。
语法：
	int regexp( string str, string pattern );
	string array regexp( string array lines, string pattern );
	string array regexp( string array lines, string pattern, int flag );

	整数 regexp( 字串 字串, 字串 样式 );
	字串 阵列 regexp( 字串 阵列 行, 字串 样式 );
	字串 阵列 regexp( 字串 阵列 行, 字串 样式, 整数 旗标 );
用法：
	第一种语法中，如果字串“str”含有符合正规表示式“pattern”的子字串 
	(substring) 时，regexp() 传回真〈即 1〉。如果想要比对是否完全符合，
	“pattern”应该以“^”开头，而以“$”结尾。

	一般而言，当以多行文字的阵列和正规表示式表达时，regexp() 会传回一个
	含有那几行符合指定的正规表示式文字之阵列。如果 (flag & 2) 不为零，
	（预设值 0），则将传回不符合者而非符合者。如果 (flag & 1) 不为零，
	则会传回这种格式的阵列：
	({ 索引 1 + 1,	符合 1, ..., 索引 n + 1, 符合 n }) 的阵列，这里的索
	引 1 是指第一个符合／不符合者在文字行阵列中的索引 (index)。

正规表示式语法：

	一个正规表示式含有零个或是多个由“|”分隔的“分段”(branch)。它可找
	出符合这些分段之一的任何东西。

	一个分段是由零个或多个“部份”(piece) 相连而成的。它可依序相配符合
	的第一个单元、第二个单元等等。

	一个部份是一个可能会接着“*”、“+”或“?”的“单元”(atom)。
	一个接着“*”的单元可以相配一串零个以上符合的单元。
	一个接着“+”的单元可以相配一串一个以上符合的单元。
	一个接着“?”的单元可以相配一个单元或是虚字串 (null string)。

	一个单元是一个在括弧中的正规表示式（相配一个正规表示式）、一个“范
	围”(range)（后面会说明）、“.”（相配任何单一字元）、“^”（相配输
	入字串开头的虚字串）、“$”（相配输入字串结尾的虚字串）、一个接着单
	一字元的“\”（配对此字元）或是一个没有其他意义的单一字元（相配这个
	字元）。

	一个“范围”是一个包含在“[]”内的字元序列 (sequence)。
	它一般是相配任何在序列中的任何单一字元。如果这个序列以“^”开始，则
	它只能相配“不是”来自序列剩余部份的任何单一字元。如果在序列中的二
	个字元中间夹有“-”，则这是个含有介于它们间所有 ASCII 字元的简写（
	例如，“[0-9]”可相配任何 0 到 9 的数字）。
	要在序列中包含字元“]”的话，就要将它放在第一个字元〈有可能放在
	“^”后面〉。
	要包含字元“-”的话，要把它放在第一个或最后一个字元。

不明确性 (ambiguity)：

	如果一个正规表示式可以符合输入字串的二个不同部份，则它将只会相配较
	早开始的那一个。若二个都在相同位置开始但符合长度不同，或是符合方法
	不同而同长度的话，情况就会变的很复杂，详述如下：

	一般上来说，一串分段列表的可能性是依由左至右的顺序，“*”、“+”和
	“?”总是尽量相配最长的字串，巢状结构会由外层开始，而连结 
	(concatenated) 的结构是由最左边的开始。将会选用的符合结果是采用最
	早可能性的选择。
	如果有多于一个的选择，则下一个也会因第一个选择而采取同样的方法（最
	早可能性），之后继续。

	举例来说，“(ab|a)b*c”可以有二种方式相配“abc”。第一个选择是
	“ab”或“a”；因为“ab”较早符合而且可以相配成功，所以它被选用。由
	于“b”已符合，所以“b*”必须相配它最后的可能──空字串，因为它必须
	遵从较早的选择。

	一个没有“|”而只有一个“*”、“+”或“?”的特殊情况，它的效果是会
	选用最长的可能符合者。因此，对“xabbby”来说，“ab*”将会相配
	“abbbb”。注意，如果改成“xabyabbbz”，它将只会相配到“x”之后的
	“ab”，因为它遵守“开始最早守则”(begins-earliest rule)。（结果是
	，决定从哪里开始相配是第一个要做的选择，因为其后的选择必须遵从它，
	即使会导致比较不好的选择结果。）
参考：
	sscanf, explode, strsrch
作者：
	Tim Hollebeek  Beek@ZorkMUD, Lima Bean, IdeaExchange, and elsewhere
原译：
	Kenny@Broken.History	97.Jul.26
校订：
	spock@muds.net		2000.Aug.28.	v22 版
